structure A = Absyn

%%
%term
    EOF 
  | ID of string
  | INT of int | STRING of string 
  | COMMA | COLON | SEMICOLON | LPAREN | RPAREN | LBRACK | RBRACK 
  | LBRACE | RBRACE | DOT 
  | PLUS | MINUS | TIMES | DIVIDE | UMINUS | EQ | NEQ | LT | LE | GT | GE
  | AND | OR | ASSIGN
  | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
  | BREAK | NIL
  | FUNCTION | VAR | TYPE | LVAL | IFTHN

%nonterm exp of A.exp | program of A.exp |  lvalue of A.exp | expseq of (A.exp * pos) list | expcomma of A.exp list | decs of A.dec list | dec of A.dec | vardec of A.dec | fundecs of A.fundec list | fundec of A.fundec | ty of A.ty | tydec of {name: Symbol.symbol, ty: A.ty, pos: pos} list |  tyfields of A.field list | recdec of (Symbol.symbol * A.exp * pos) list

%pos int
%verbose
%start program
%eop EOF
%noshift EOF

%name Tiger

%keyword WHILE FOR TO BREAK LET IN END FUNCTION VAR TYPE ARRAY IF THEN ELSE 
	DO OF NIL

%prefer THEN ELSE LPAREN

%value ID ("bogus")
%value INT (1)
%value STRING ("")

%right LVAL
%right STRING
%left INT
%left DOT
%left ASSIGN
%left OR
%left AND
%left NIL 
%nonassoc EQ NEQ GT GE LT LE
%left PLUS MINUS
%left DIVIDE TIMES
%right LBRACK RBRACK
%left UMINUS
%%

program	: exp				(exp)

	
exp : lvalue %prec LVAL   (lvalue)
    | INT   (A.IntExp(INT))
    | STRING   (A.StringExp(STRING, STRINGright))
    | NIL   (A.NilExp)
    | BREAK   (A.BreakExp(BREAKright))
    | LPAREN RPAREN (A.SeqExp([]))
    | LPAREN expseq RPAREN   (A.SeqExp(expseq))
    | IF exp THEN exp (A.IfExp{test = exp1, then' = exp2, else' = NONE, pos = expright})
    | IF exp THEN exp ELSE exp   (A.IfExp({test = exp1, then' = exp2, else' = SOME exp3, pos = expright}))
    | FOR ID ASSIGN exp TO exp DO exp   (A.ForExp({var = Symbol.symbol(ID), escape = ref true, lo = exp1, hi = exp2, body = exp3, pos = exp3right}))
    | WHILE exp DO exp   (A.WhileExp({test = exp1, body = exp2, pos = exp2right}))
    | LET decs IN expseq END   (A.LetExp({decs = decs, body = A.SeqExp(expseq), pos = ENDright}))
    | MINUS exp   %prec UMINUS   (A.OpExp({left = A.IntExp(0), oper = A.MinusOp, right = exp, pos = expright}))
    | exp EQ exp   (A.OpExp({left = exp1, oper = A.EqOp, right = exp2, pos = exp2right}))
    | exp NEQ exp   (A.OpExp({left = exp1, oper = A.NeqOp, right = exp2, pos = exp2right}))
    | exp LT exp   (A.OpExp({left = exp1, oper = A.LtOp, right = exp2, pos = exp2right}))
    | exp GT exp   (A.OpExp({left = exp1, oper = A.GtOp, right = exp2, pos = exp2right}))
    | exp GE exp   (A.OpExp({left = exp1, oper = A.GeOp, right = exp2, pos = exp2right}))
    | exp LE exp   (A.OpExp({left = exp1, oper = A.LeOp, right = exp2, pos = exp2right}))
    | exp AND exp   (A.IfExp({test = exp1, then' = exp2, else' = SOME (A.IntExp(0)), pos = exp2right}))
    | exp OR exp   (A.IfExp({test = exp1, then' = A.IntExp(1), else' = SOME exp2, pos = exp2right}))
    | exp TIMES exp   (A.OpExp({left = exp1, oper = A.TimesOp, right = exp2, pos = exp2right}))
    | exp DIVIDE exp   (A.OpExp({left = exp1, oper = A.DivideOp, right = exp2, pos = exp2right}))
    | exp PLUS exp   (A.OpExp({left = exp1, oper = A.PlusOp, right = exp2, pos = expright}))
    | exp MINUS exp   (A.OpExp({left = exp1, oper = A.MinusOp, right = exp2, pos = exp2right}))


lvalue : ID   (A.VarExp(A.SimpleVar(Symbol.symbol(ID), IDright)))
       | ID LPAREN RPAREN   (A.CallExp({func = Symbol.symbol(ID), args = [], pos = RPARENright}))
       | ID LBRACE RBRACE   (A.RecordExp({typ = Symbol.symbol(ID), fields = [], pos = RBRACEright}))
       | ID LPAREN expcomma RPAREN   (A.CallExp({func = Symbol.symbol(ID), args = expcomma, pos = RPARENright}))
       | ID LBRACE recdec RBRACE   (A.RecordExp({typ = Symbol.symbol(ID), fields = recdec, pos = RBRACEright}))
       | ID LBRACK exp RBRACK   (A.VarExp(A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID), IDright), exp, expright)))
       | ID LBRACK exp RBRACK LBRACK exp RBRACK  (A.VarExp(A.SubscriptVar(A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID), IDright), exp2, exp2right), exp1, exp1right)))
       | ID LBRACK exp RBRACK OF exp   (A.ArrayExp({typ = Symbol.symbol(ID), size = exp1, init = exp2, pos = expright}))
       | ID LBRACK exp RBRACK ASSIGN exp  (A.AssignExp({var = A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID), IDright), exp1, exp1right), exp = exp2, pos = exp2right}))
       | ID LBRACK exp RBRACK DOT ID  (A.VarExp(A.FieldVar(A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID), IDright), exp, expright), Symbol.symbol(ID2), ID2right)))
       | ID LBRACK exp RBRACK LBRACK exp RBRACK DOT ID  (A.VarExp(A.FieldVar(A.SubscriptVar(A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID), IDright), exp2, exp2right), exp1, exp1right), Symbol.symbol(ID2), ID2right)))
       | ID LBRACK exp RBRACK LBRACK exp RBRACK DOT ID LBRACK exp RBRACK (A.VarExp(A.SubscriptVar(A.FieldVar(A.SubscriptVar(A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID), IDright), exp2, exp2right), exp1, exp1right), Symbol.symbol(ID2), ID2right), exp3, exp3right)))
       | ID LBRACK exp RBRACK DOT ID ASSIGN exp  (A.AssignExp({var = A.FieldVar(A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID1), ID1right), exp1, exp1right), Symbol.symbol(ID2), ID2right), exp = exp2, pos = expright}))
       | ID LBRACK exp RBRACK LBRACK exp RBRACK DOT ID ASSIGN exp  (A.AssignExp({var = A.FieldVar(A.SubscriptVar(A.SubscriptVar(A.SimpleVar(Symbol.symbol(ID1), ID1right), exp2, exp2right), exp1, exp1right), Symbol.symbol(ID2), ID2right), exp = exp3, pos = exp3right}))
       | ID DOT ID   (A.VarExp(A.FieldVar(A.SimpleVar(Symbol.symbol(ID1), IDright), Symbol.symbol(ID2), IDright)))
       | ID DOT ID ASSIGN exp  (A.AssignExp({ var = A.FieldVar(A.SimpleVar(Symbol.symbol(ID1), IDright), Symbol.symbol(ID2), ID2right), exp = exp, pos = expright}))
       | ID DOT ID LBRACK exp RBRACK ASSIGN exp  (A.AssignExp({ var = A.SubscriptVar(A.FieldVar(A.SimpleVar(Symbol.symbol(ID1), IDright), Symbol.symbol(ID2), ID2right), exp1, exp1right), exp = exp2, pos = exp2right}))
       | ID ASSIGN exp  (A.AssignExp({var = A.SimpleVar(Symbol.symbol(ID), IDright), exp = exp, pos = expright}))

(*A.VarExp(A.FieldVar(A.SimpleVar(Symbol.symbol(ID), IDright), Symbol.symbol(""), RBRACEright))*)

expseq : exp SEMICOLON expseq   ((exp, expright) :: expseq)
       | exp   ([(exp, expright)])

expcomma : exp COMMA expcomma   (exp :: expcomma)
         | exp   ([exp])

decs : dec decs (dec :: decs)
     | dec   ([dec])

dec  : tydec    (A.TypeDec(tydec))
     | vardec  (vardec)
     | fundecs   (A.FunctionDec(fundecs))

tydec : TYPE ID EQ ty tydec   ({name = Symbol.symbol(ID), ty = ty, pos = tyright} :: tydec)
      | TYPE ID EQ ty   ([{name = Symbol.symbol(ID), ty = ty, pos = tyright}])

ty : ID   (A.NameTy(Symbol.symbol(ID), IDright))
   | LBRACE tyfields RBRACE   (A.RecordTy(tyfields))
   | ARRAY OF ID   (A.ArrayTy(Symbol.symbol(ID), IDright))

tyfields : ID COLON ID COMMA tyfields  (let
                                           val x : A.field = {name = Symbol.symbol(ID1), escape = ref true, typ = Symbol.symbol(ID2), pos = COMMAright}
                                        in
                                           x :: tyfields
                                        end)
         | ID COLON ID   ([{name = Symbol.symbol(ID1), escape = ref true, typ = Symbol.symbol(ID2), pos = IDright}])

vardec : VAR ID ASSIGN exp   (A.VarDec({name = Symbol.symbol(ID), escape = ref true, typ = NONE, init = exp, pos = ASSIGNright}))
       | VAR ID COLON ID ASSIGN exp   (A.VarDec({name = Symbol.symbol(ID1), escape = ref true, typ = SOME (Symbol.symbol(ID2), ID2right), init = exp, pos = ASSIGNright}))

fundecs : fundec fundecs   (fundec :: fundecs)
        | fundec   ([fundec])

fundec : FUNCTION ID LPAREN tyfields RPAREN EQ exp (let
                                                       val x : A.fundec = {name = Symbol.symbol(ID), params = tyfields, result = NONE, body = exp, pos = EQright}
                                                    in
                                                       x
                                                    end)
       | FUNCTION ID LPAREN RPAREN EQ exp   (let 
                                                val x : A.fundec = {name = Symbol.symbol(ID), params = [], result = NONE, body = exp, pos = EQright}
                                             in
                                                x
                                             end)
       | FUNCTION ID LPAREN tyfields RPAREN COLON ID EQ exp (let
                                                                val x : A.fundec = {name = Symbol.symbol(ID1), params = tyfields, result = SOME (Symbol.symbol(ID2), ID2right), body = exp, pos = EQright}
                                                             in
                                                                x
                                                             end)
       | FUNCTION ID LPAREN RPAREN COLON ID EQ exp   (let
                                                         val x : A.fundec = {name = Symbol.symbol(ID1), params = [], result = SOME (Symbol.symbol(ID2), ID2right), body = exp, pos = EQright}
                                                      in
                                                         x
                                                      end)
       
recdec : ID EQ exp COMMA recdec   ((Symbol.symbol(ID), exp, expright) :: recdec)
       | ID EQ exp   ([(Symbol.symbol(ID), exp, expright)])
